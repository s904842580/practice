shift+F6 批量改统一的变量名
类的创建方法就是jdk里面的构造方法
在输入中new就是构造方法
length();用于求字符串中字符的个数
length;求字符串数组中有多少个字符串



Scanner类的功能，可以实现键盘输入数据到程序当中（但要建立对象，Scanner只是一个功能）
引用类型的一般使用步骤：
1.导包 
import 包路径.类名称（只有Java.lang包下的内容不需要导包）
2.创建
类名称 对象名 = new 类名称();
3.使用
对象名.成员方法名()
Scanner的jdk构造方法中括号中都不是空值
Scanner sc = new Scanner(System.in);  System.in 代表从键盘进行输入

匿名对象只能使用唯一的一次，确定一个对象只需要使用唯一的一次就可以使用
（匿名对象也可以使用在返回值中： return new……）
普通使用方式：Scanner sc = new Scanner(System.in);
              int num = sc.nextInt();
              System.out.println("输入的是：" + num);
匿名使用方式：int num = new Scanner(System.in).nextInt();
              System.out.println("输入的是：" + num);

对于ArrayList来说，有一个尖括号<E>代表泛型
ArraList导包：  import java.util.ArrayList;
泛型，也就是装在集合当中的所有元素，全都是统一的类型（泛型只能是引用类型，不能是基本类型）
ArrayList<String> list = new ArrayList<>();
创建了一个ArrayList集合，集合的名称是List，里面装的全都是String字符串类型的数据，如果什么都不添加输出一个[];
添加一个元素：list.add("");带有一个返回值但对于它一定会添加成功
打印一个元素：list.get(0);
删除一个元素：list.remove(0);
获取集合的长度：list.size();

定义方法三要素：
1.返回值类型 2.方法名称 3.参数列表

String：
当程序所有的双引号字符串，都是String类的对象，没有new也是
字符串不可改变，所以可以共享使用
创建字符串的3+1种方式：
public String();创建一个空白字符串，不含任何内容
public String(char[] array);根据字符数组的内容，创建对应的字符串
public String(byte[] array);根据字节数组的内容，创建对应的字符串

字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中，但new的不在常量池中
基本类型：==是进行数值的比较
引用类型：==是进行【地址值】 的比较

equals是对字符串的内容比较
length();获取字符串当中含有的字符个数，拿到字符串长度
concat(String str);当前字符串和参数字符串拼接成为返回值的新的字符
charAt(int index);获取指定位置的单个字符（从零开始计数）
indexOf(String str);查找参数字符串在本字符中首次出现的位置，没有返回-1

字符串的截取方法：
substring(int index);截取从参数位置到字符串末尾，返回新字符串
substring(int begin, int end);截取从begin开始到end结束（左闭右开）

toCharArray();将当前字符串拆分成字符数组作为返回值
getBytes();转换成字节数组用一个byte[] 数组来接收
replace(oldString, newString)将老字符串转换成字符串并返回新的值

分割字符串的方法：
split(String regex);按照字符串的规则分割返回新的值
注意事项：split方法的参数是一个“正则表达式”
如果按照英文句点“.”进行切分，必须写“\\.”（两个反斜杠）

使用static修饰成员方法，就成为静态方法。静态方法不属于对象，而是属于类
如果没有static关键字，必须先创建对象再使用（类名称 对象名 = new 类名称();）
有static关键字，可以直接使用（类名称.静态方法名称）
静态不能访问非静态（内存先有静态再有费非静态）
静态不能使用this（this代表当前对象，但静态跟对象没关系，静态只跟类有关系）
静态内容优先于构造方法，静态代码块只会执行唯一的一次

java.util.Arrays
Arrays于数组相关的工具类
默认格式字符串：[a,b,c]
public static String toString(数组)将参数变成（默认）字符串
public static void sort(数组)按照默认升序（从小到大）进行排序
注意Arrays是对数组进行排序，如果是字符串需要用toCharArray

Java.util.Math
public static double abs（double num）取绝对值
public static double ceil（double num）向上取整
public static double floor（double nun）向下取整
public static long round （double num）四舍五入

面向过程要详细处理每一个细节，强调步骤
面对对象就可以使用现成的，将事情简单化
面向对象的三大特征：封装性、继承性、多态性

类是一组相关属性和行为的集合，是抽象的
对象是具体的
类是对象的模板，对象是类的实体
属性就是状态信息
行为就是能做什么

成员方法没有static
成员变量使用：对象名.成员变量名
成员方法使用：对象名.成员方法名（参数）
如果成员变量没有进行赋值会有一个默认值

一个标准的类的构成：（也叫做Java Bean）
1.所有的成员变量都要使用private关键字修饰
2.为每一个成员变量编写一对Getter/Setter方法
3.编写一个无参数的构造方法
4.编写一个全参数的构造方法


继承是多态的前提，如果没有继承，就没有多态
继承主要解决的问题就是：共性抽取
子类可以拥有父类有的内容，还可以有自己的
定义子类的格式：public class 子类名称 extends 父类名称
直接通过子类对象访问成员变量
    等号左边是谁，就优先用谁，没有则向上找
间接通过成员方法访问成员变量
    该方法属于谁，就优先用谁，没有则向上找

局部变量          直接写成员变量名
本类的成员变量    this.成员变量名
父类的成员变量    super.成员变量名

重写（Override）：方法的名称一样，参数列表【也一样】覆盖，覆写
重载（OverLoad）：方法的名称一样，参数列表【不一样】

覆盖注意事项：
@Override写在方法前面，用来检测是不是有效的正确覆盖重写（安全检测功能）
子类方法的返回值必须【小于或等于】父类方法的返回值范围
Java.Lang.Object类是所有类的公共最高的父类（祖宗类）
Java.Lang.String类就是Object的子类 
子类方法的权限必须【大于等于】父类方法的权限修饰符
扩展：public > protected > default > private
default不是关键字default,而是什么都不写，留空

子类构造方法当中有一个默认隐含的“super（）”调用，所以一定是先调用的父类构造，后执行的子类构造
子类构造可以通过super关键字来调用父类重载构造
super的父类构造调用，必须是子类构造方法的第一个语句，不能是一个子类构造调用多次super构造
子类必须调用父类方法，不写则赠送super（）；写了则用写的指定的super调用，super只能有一个，还必须是第一个

super关键字用来访问父类内容，this用来访问本类内容

super关键字的用法：
1.在子类的成员方法中，访问父类的成员变量
2.在子类的成员方法中，访问父类的成员方法
3.在子类的构造方法中，访问父类的构造方法

this关键字的用法：
1.在本类的成员方法中，访问本类的成员变量
2.在本类的成员方法中，访问本类的另一个成员方法（起强调作用）
3.在本类的构造方法中，访问本类的另一个构造方法
在第三种方法当中要注意：
A.this（……）调用也必须是构造方法的第一个语句，唯一一个
B.super和this两种构造调用，不能同时使用

Java语言是单继承的
一个类的直接父类只能有唯一一个
Java语言可以多级继承
一个子类的直接父亲是唯一的，但是一个父亲可以拥有很多个子类

抽象的定义：
如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是一个抽象方法
抽象方法，就是加上abstract关键字，然后去掉大括号，直接分号结束
抽象类，抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可

如何使用抽象类和抽象方法：
1.不能直接创建new抽象类对象
2.必须用一个子类来继承抽象父类
3.子类必须覆盖重写抽象父类当中所有的抽象方法
覆盖重写（实现），子类去掉抽象方法的abstract关键字，然后补上方法体大括号
4.创建子类对象进行使用

抽象类使用注意事项：
1.抽象类不能创建对象
2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的
3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类
4.抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错





接口：
定义：接口就是一种公共的规范标准
只要符合规范标准，就可以大家通用
USB就是item提出的统一的接口
代码中接口就是多个类的公共规范
接口是一种引用的数据类型，最重要的内容就是其中的，抽象方法
如何定义一个接口的格式：
public interface 接口名称{
  // 接口内容
}
备注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java-->.class
接口中可以包含的内容：
1.常量
2.抽象方法
3.默认方法（Java8之后）
4.静态方法（Java8之后）
5.私有方法（Java9之后）
在任何版本的Java中，接口都能定义抽象方法
public abstract 返回值类型 方法名称（参数列表）
注意事项：
1.接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract
2.这两个关键字修饰符，可以选择地省略
3.方法的三要素，可以随意定义

接口使用的步骤：
1.接口不能直接使用，必须有一个“实现类”来“实现”该接口
格式：
public class 实现类名称 implement 接口名称{
   // ……
}
2.接口的实现类必须覆盖重写（实现）接口中所有的抽象方法
3.创建实现类的对象，进行使用

注意事项：
如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类

在主程序中不能直接new接口对象使用，要创建实现类的对象使用

从Java 8开始，接口里允许定义默认方法
格式：
public default 返回值类型 方法名称（参数列表）{
   方法体
}
备注：接口当中的默认方法，可以解决接口升级的问题
当从接口里添加新的抽象方法，每个子类也要添加，这就是接口升级问题
新添加的方法，改成默认方法，默认方法可以被实现类继承下来，就是可以直接用
public default void 方法名称（）{
  //方法体
}
1.接口的默认方法，可以通过接口实现类对象，直接调用
2.接口的默认方法，也可以被接口实现类进行覆盖重写

从Java8开始，接口当中允许定义静态方法
格式：
public static 放回值类型 方法名称（参数列表）{
  方法体
}
提示：就是讲abstract或者default换成static即可，带上方法体
不能通过接口实现类的对象的调用接口当中的静态方法，要通过接口名称没直接调用其中的静态方法
格式：
接口名称.静态方法名（参数）；

Java9开始，接口当中允许定义私有方法
1.普通私有方法，解决多个默认方法之间重复代码问题
格式：
private 返回值类型 方法名称（参数列表）{
方法体
}
2.静态私有方法，解决多个静态方法之间重复代码问题
格式：
private static 返回值类型 方法名称（参数列表）{
   方法体
}

接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰
从效果上来看，这就是接口的【常量】
格式：
public static final 数据类型 常量名称 = 数据值;
一旦使用final关键字进行修饰，说明不可改变
注意事项：
1.接口当中的常量，可以省略public static final，不写也是这样
2.接口当中的常量，必须进行赋值;不能不赋值
3.接口当中常量的名称，使用完全大写的字母，用下划线进行分隔（推荐命名规则）

小结：
在Java 9+版本中，接口的内容可以有：
1.成员变量其实是常量，格式：
[public] [static] [final] 数据类型 常量名称 = 数据值;    []是可省略部分
注意：
     常量笔试进行赋值，而且一旦赋值不能改变
     常量名称完全大写，用下划线进行分隔

2.接口汇总最重要的就是抽象方法，格式：
[public] [abstract] 返回值类型 方法名称（参数列表）;
注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类

3.从Java 8开始，接口里允许定义默认方法，格式：
[public] default 返回值类型 方法名称（参数列表）{方法体}
注意：默认方法也可以被覆盖重写

4.从Java 8开始，接口里允许定义静态方法，格式：
[public] static 返回值类型 方法名称（参数列表）{方法体}
注意：应该通过接口名称进行调用们不能通过实现类对象调用接口静态方法

5.从Java 9开始，接口里允许定义私有方法，格式：
普通私有方法：private 返回值类型 方法名称（参数列表）
静态私有方法：private static 返回值类型 方法名称（参数列表）{方法体}
注意：private的方法只有接口自己才能调用，不能被实现类或别人使用

使用接口的时候，需要注意：
1.接口是没有静态代码块或者构造方法的
2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口
格式：
public 才开始 MyInterfaceImpl implement MyInterfaceA，MyInterfaceB
{覆盖所有抽象方法}
3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可
4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类
5.如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写
6.一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先使用父类当中的方法

1.类与类之间是单继承的。直接父类只有一个
2.类与接口之间是多实现的，一个类可以实现多个接口
3.接口与接口之间是多继承的
注意事项：
1.多个父接口当中的抽象方法如果重复，没关系
2.多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写【而且带着default关键字】



多态：Multi
一个对象拥有多种形态，这就是对象的多态性
代码当中体现多态性，其实就是一句话，父类引用指向子类对象
格式：
父类名称 对象名 = new 子类名称();
或者
接口名称 对象名 = new 实现类名称();

访问成员变量的两种方式：
1.直接通过对象名称访问成员变量，看等号左边是谁，优先用谁，没有则向上找（直接访问就是直接.对象名称）
2.间接通过成员方法访问成员变量，看该方法属于谁，优先用谁，没有则向上找（子类覆盖先用子）

在多态的代码当中，成员方法的访问规则是
      看new的是谁，就优先用谁，没有则向上找
口诀：成员方法：编译看左边，运行看右边
      成员变量：编译看左边，运行看左边
使用多态的好处：无论右边new的时候换成那个子类对象，等号左边调用方法都不会变化（更改代码时不用改左边更加灵活）

对象的向上转型，其实就是多态写法
父类名称 对象名 = new 子类名称();
含义：右边创建一个子类对象，把它当做父类来看待使用
注意事项：向上转型一定是安全的。从小范围转向了大范围没问题
弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容

对象的向下转型，其实一个【还原】的动作
格式：子类名称 对象名 = （子类名称） 父类对象;
含义：将父类对象，【还原】成为本来的子类对象
注意事项：
a.必须保证对象本来创建的时候，就是猫，才能向下转型成为猫
b.如果对象创建的时候不是猫，现在非要向下转型成为猫就会报错。ClassCastException
类似于：强制类型转换

如何才能知道一个父类应用的对象，本来是什么子类？
格式：
对象 instanceof 类名称
这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例



Collection方法
共性方法：
public boolean add(E e); 把给定的对象添加到当前的集合中











































18866395304




















Impl在接口实现类的后面
alt+回车 处理错误

